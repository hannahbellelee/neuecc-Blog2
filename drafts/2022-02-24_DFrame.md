# DFrame - C#でテストシナリオを書く分散負荷テストフレームワーク

と、いうものをリリースしました。Web UIとなるDFrame.Controllerと、負荷テストシナリオをC#で書くDFrame.Workerの組み合わせで成り立っていて、DFrame.Workerをウェブ上のクラスターに配置することで(Controllerと接続するただの常駐アプリなので、配置先はオンプレでもVMでもコンテナでもKuberenetesでもなんでもいい)、1から数千のワーカーが連動して、大量のリクエストを発生させます。また、テストシナリオをプレーンなC#で記述できるということは、HTTP/1だけではなく、あらゆる種類の通信をカバーできます。WebSocket、HTTP/2、gRPC、MagicOnion、あるいはPhotonや自作のTCPトランスポート、更にはRedisやデータベースなどを対象にすることも。

DFrame.Workerは通常の.NETの他に、Unityにも対応しています！つまり、大量のHeadless Unity、あるいはデバイスファームに配置することで、Unityでしか動かないような独自通信フレームワークであっても負荷テストをかけることが可能です。

* [github - Cysharp/DFrame](https://github.com/Cysharp/DFrame/)

// TODO:画像

Web UI(DFrame.Controller)はBlazor Serverで作られていて、分散ワーカーとの通信はMagicOnionで行っています。自動化のためのWeb APIの口もあるため、Blazor Server, ASP.NET Minimum API, MagicOnionのキメラ同居なアーキテクチャでC#でフル活用なのが設計的にも面白いポイントです。

C#で負荷テストシナリオを書く意義
---
負荷テストフレームワークは世の中に山のようにあります。代表的なものでも[ab](https://httpd.apache.org/docs/2.4/programs/ab.html), [jMeter](https://jmeter.apache.org/), [k6](
https://k6.io/), [Artillery](https://www.artillery.io/), [Gatling](https://gatling.io/), [wrk](
https://github.com/wg/wrk), [bombardier](https://github.com/codesenberg/bombardier), [locust](https://locust.io/)、k6やArtillery、GatlingなどはSaaSとしても提供していますし、クラウドサービス側も、[Azure Load Testing(Managed jMeter)](
https://azure.microsoft.com/ja-jp/services/load-testing/)のようなマネージドサービスを出していますし、.NETでも[dotnet/crank](https://github.com/dotnet/crank)というものが存在していたりします。

DFrameはこの中でいうとアーキテクチャ含めlocustに近いのですが、その特徴の中で重要な点として挙げられているのが、シナリオをコードで書けること、です。よくわからんUIで設定させたり、複雑怪奇なXMLやYAMLやJSON書かせたりせず、プレーンなコードで書ける。これが大事。LocustはPythonですが、他にk6はJavaScriptで書けるようになっています。

TODO:この辺整理


じゃあそれらじゃ何が悪いんですか、というと、C#で書けるものがないから。なぜC#で書きたいのか、というと、サーバーあるいはクライアント言語と負荷試験シナリオ作成言語を同一のものにしたいからです。例えばUnityをターゲットにする場合、UnityのゲームはC#で記述されていますが、その場合

* 最初からクライアントSDKに相当するものがある
* クライアントの実装と完全に等しいのでゲームのドメインロジックが最初からある

となります。もちろん、Unity依存の部分を引き剥がすなどの追加の作業は必要ですが、完全に書き起こすなどといった無駄は発生しません。

もし異なる言語である場合は、作業量が膨大です。



DFrameApp.Run
---







パフォーマンス
---
デフォルトでは一回の実行が終わる度に、結果をControllerに送信しています。これはグルグルといっぱい数字が回転してくのを眺められて気持ちが良いんですが、無駄です。実際かなり性能に影響が出ます。

Open source load testing tool review 2020
https://k6.io/blog/comparing-best-open-source-load-testing-tools/


自動化のためのREST API
---


ライブラリかツールか
---
Controllerも完全にライブラリとして提供しているんですね、なので自分で組み込んでビルドしなきゃいけない。

TODO: コンフィグむずかしいかんたんほげもげ



Blazor Server + MagicOnion
---


紆余曲折
---
最初のバージョンは2年ぐらい前に作っていました。コンセプトは「自己分裂する分散バッチフレームワーク」ということで、自分自身のコピーを動的に作って無限大に分散して実行していくというもので。分散のための基盤としてKubernetesを使う感じで。クラウドネイティブ！かっこいい！そして、一応動くものはできていました。あとは仕上げていくだけ、といったところで、放置していました。完成させなきゃ、と思いつつ、内心薄々あんまいい感じではないな、と思っていたため手が進まず無限放置モードへ。そして時が流れ、社内でもがっつり使うことになり引っ張り出されてきたそれは、やはりあまりいい感じではなく。で、最終的に言われたんですね、そもそも分裂機能いらなくね？と。

それでようやく気づくわけです、コンセプトから完全に間違っているからうまくいくわけがない！

反省として良くなかった理由としては、まず、現代のクラウドコンピューターを過大に評価していた。「自己分裂する」のは、一瞬で無限大にスケールして即起動、そして終わったら即終了、ならば、まぁそれでいいんですが、現実のスケールする時間はそんなに立派じゃない。サーバーレスといいつつ、別に1リクエスト毎にコンテナが起動して処理するわけはなく、常駐してリクエストを待つ。そりゃそうだ、と。自己分裂のコンセプトだと、分裂コストが重たいのは否めない。

もう一つは分裂するためのコードがDFrame内に記述されている。Kuberentesをコントロールするコードがたっぷり入ってしまって。そのせいでコードサイズが膨らんでしまったし、使う方も複雑なコンフィグをDFrame側に埋めなきゃいけなくなってしまった。これは二重にイケてない。作るのも複雑で、使うのも複雑ですからね、いいところがない……。

と、いうわけで、最初のかっこいいコンセプトを否定して、自己分裂しない。単純に繋ぎに行くだけ。としたことで、頭を抱えてうまくいかないと感じていた行き詰まりは解消したのでした。ある意味でフツーなので、自己分裂以下略のほうがカッコイイ気はしなくもないのですが、いや、フツーが一番。

まとめ
---
TODO