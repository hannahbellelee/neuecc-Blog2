# R3 - dotnet/reactiveとUniRxの新しい現代的再実装

先日、新しいC#用のReactive Extensionsの実装としてR3を正式公開しました！R3は[Rx for .NET](https://github.com/dotnet/reactive)を第一世代、[UniRx](https://github.com/neuecc/UniRx)を第二世代とした場合の、第三世代のRxという意味で命名しています。


// TODO: もう少しこの辺に説明いれる


* [GitHub - Cysharp/R3](https://github.com/Cysharp/R3)

幾つかの破壊的変更を含むため、ドロップインリプレースメントではないですが、dotnet/reactiveやUniRxからの移行も現実的に可能な範囲に収めてあります。この辺は語彙や操作がLINQ的に共通化されているというRxの良いところで、そこのところは大きく変わりはありません。思ったよりも何も変わっていない、といったような印象すら抱けるかもしれませんが、そう思っていただければ、それはそれでR3の設計としては大成功ということになります。

なので基本的なところはRxですし、使えるところも変わりないです。よって、押さえておくべきことは、なぜ今R3という新たな実装が必要になったかということと、Rx for .NET, UniRxとの違いはどこかということです。（新規の人は何も考えず使ってください……！）

Rxの歴史と vs async/await
---
Rx使ってますか？という問いに、使ってません、と答える人も増えてきました。別にこれは.NETやUnityだけの話ではなく、JavaでもSwiftでもKotlinでも。明らかにプレゼンスが低下しています。なぜか？というと、それはもう簡単です。async/awaitが登場したから。.NETのReactive Extensionsが初登場したのは2009年。C# 3.0, .NET Framework 3.5の頃であり、対応プラットフォームもSilverlightやWindows Phoneといった、今はもう消滅したプラットフォームも並んでくるような時代。もちろん、async/await(初登場はC# 5.0, 2012年)も存在していません。まだTaskすら導入されていなかった頃です。余談ですがReactive Extensionsの"Extensions"は、先行して開発されていた[Parallel Extensions](https://en.wikipedia.org/wiki/Parallel_Extensions)(Parallel LINQやTask Parallel Library, .NET Framework 4.0で追加された)から名前が取られとされています。

Rxは、まず、言語サポートのない非同期処理の決定版として、あらゆる言語に普及し一世を風靡しました。単機能なTaskやPromiseよりも、豊富なオペレーターを備えたRxのほうが使いやすいし遥かに強力！私も当時はTPLいらね、とRxに夢中になったものです。しかしasync/awaitが追加されて以降の結果はご存じの通り。async/awaitこそが非同期処理の決定版として、これまたC#からあらゆる言語に普及し、非同期処理におけるスタンダードとなりました。（ちなみにF#こそが発祥だって言う人もいますが、国内海外問わず当時のF#コミュニティのC# async/awaitへの反発と難癖の数々はよーく覚えているので、あ、そうですか、ぐらいの感じです。awaitないしね）

async/awaitが普及したことにより、とりあえず非同期処理のためにRxを入れるという需要はなくなり、Rxの採用率は下がっていったのであった。UnityにおいてのRxのスタンダードであった[UniRx](https://github.com/neuecc/UniRx/)の開発者である私も、別にそれに固執することはなく、むしろゲームエンジン(Unity)に特化したasync/awaitランタイムが必要であると素早く認知し、Unityにおいて必要な条件(C# 7.0)が揃ったタイミングで即座に[UniTask](https://github.com/Cysharp/UniTask)を開発し、今ではUniTaskは絶対に入れるけどUniRxは入れない、といった開発者も増えてきました。

Rxの価値の再発見
---
そもそもRxって別に非同期処理のためだけのシステムではないですよね？LINQ to Everythingではあったけれど、むしろEverythingというのはノイズで、分離するものは分離したほうがいい、最適なものはそれを使ったほうがいい。Rxを非同期処理のために使うべきではないし、長さ1のObservableはTaskで表現したほうが、分かりやすさにおいてもパフォーマンスにおいても利点がある。そうなるとRxにはasync/awaitと統合されたAPIも必要で、それはObservableはモナドだからSelectManyにTaskを渡せることもできるだとか、そんなどうでもいいことではなくて、真剣にasync/awaitと共存するRxを考えてみると、手を加えなければならないAPIは多数ある。

単純にawaitできるだけではなく現実のアプリケーション開発には少し足りない。そこで非同期処理に関しては様々なライブラリが考案されてきました。そして今は2024年、勝者は決まりました。[TPL Dataflow](https://learn.microsoft.com/ja-jp/dotnet/standard/parallel-programming/dataflow-task-parallel-library)を好んで今から使おうとする人もいないでしょう。言語サポートの[IAsyncEnumerable](https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/generate-consume-asynchronous-stream)と[System.Threading.Channels](https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/)がベストです。また、これらはバックプレッシャーの性質も内包しているため、RxJavaなどにあるバックプレッシャーに関するオペレーターは.NETには不要でしょう。もう少し具体的なI/Oに関する処理が必要なら[System.IO.Pipelines](https://learn.microsoft.com/ja-jp/dotnet/standard/io/pipelines)を選べば、最大のパフォーマンスを発揮できる。

非同期LINQはあってもいいけれど、実際の非同期ストリームのシナリオからするとLINQ to Objectsと違い利用頻度も少ないので、別に積極的に導入したいというほどの代物ではない(なお、これは私はUniTaskに[UniTaskAsyncEnumerableとLINQ](https://github.com/Cysharp/UniTask/tree/809d23e/src/UniTask/Assets/Plugins/UniTask/Runtime/Linq)を自分で実装して提供している上での発言です)。Rxの夢の一つとして分散クエリ(IQbservable)がありましたが、それも、現代での勝者は[GraphQL](https://graphql.org/)になるでしょう。分散システムという点では[Kubernetes](https://kubernetes.io/)が普及し、RPCとしては[gRPC](https://grpc.io/)がスタンダードとして君臨し、[Orleans](https://learn.microsoft.com/en-us/dotnet/orleans/), [Akka.NET](https://getakka.net/), [SignalR](https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction)、[MagicOnion](https://github.com/Cysharp/MagicOnion)といったような選択肢のバリエーションもある。

今は様々なテクノロジーが覇権を争った2009年ではない。現代で[Service Fabric](https://azure.microsoft.com/ja-jp/products/service-fabric)を選ぶ人などいないように、今からそこに乗り出して勝ち筋を見出すのは難しい。そうした分散処理に進むことはRxの未来ではない。と、私は考えています。Rxを生み出したのがCloud Programmability Teamであるからといって、Cloudで活用できるようにすることが原点で正しいなどということもないだろう。

ではRxの価値はどこにあるのか、というと、原点に立ち返ってインメモリのメッセージングをLINQで処理するLINQ to Eventsにあると考えます。特にクライアントサイド、UIに対する処理は、現代でもRxが評価されているポイントであり、Rx Likeな、しかしより言語に寄り添い最適化されている[Kotlin Flow](https://kotlinlang.org/docs/flow.html)や[Swift Combine](https://developer.apple.com/documentation/combine)といった選択肢が現役で存在しています。UIだけではなく、複雑で大量のイベントが飛び交うゲームアプリケーションにおいても、ゲームエンジン(Unity)で使われているUniRxの開発者として、非常に有益であることを実感しています。

R3での再構築
---
最初に、Rxとしてのインターフェイスを100%維持しながらレガシーAPIの削除や新APIの追加をすべきか、それとも根本から変更すべきかを悩みました。しかし（私が問題だと考えている）すべての問題を解決するには抜本的な変更が必要だし、Kotlin FlowやSwift Combineの成功事例もあるので、旧来のRxとの互換性に囚われず、.NET 8, C# 12という現代のC#環境に合わせて再構築された、完全に新しいRxであるべきという路線に決めました。

といっても、最終的にはインターフェイスにそこまで大きな違いはありません。

```csharp
public abstract class Observable<T>
{
    public IDisposable Subscribe(Observer<T> observer);
}

public abstract class Observer<T> : IDisposable
{
    public void OnNext(T value);
    public void OnErrorResume(Exception error);
    public void OnCompleted(Result result); // Result is (Success | Failure)
}
```

パッと見だとOnErrorがOnErrorResumeになったことと、interfaceではなくてabstract classになったこと、ぐらいでしょうか。どうしても変更したかった点の一つがOnErrorで、パイプライン上で例外が起きると購読解除されるという挙動をやめたかった。R3では例外はOnErrorResumeに流れて、購読解除されません。かわりにOnCompletedに、SuccessまたはFailureを表すResultが渡ってくるようになっていて、こちらでパイプラインの終了が表されています。

OnErrorで停止することはRxにおける[billion-dollar mistake](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)だと思っていて、



ころで、OnErrorで停止するというのはイベントの代替、あるいは上位互換として考えるにはあまりにも不都合だ。もちろん通常のeventで例外が発生したとて停止することはない。なによりも、Rxにおいて停止したイベントを再購読するというのは非常に難しいのだ！完了する可能性があるという概念により、自動的な再購読は、完了済みのシーケンスを再購読しにかかる危険性がある。もちろんそうなれば無限ループだ。そして、それを判定し正しくハンドリングする術はない。そこで、そもそも例外で停止しないように変更した。OnErrorという命名のままでは従来の停止する動作と混同する可能性があるため、かわりにOnErrorResumeとして……。停止しない挙動が不都合ならば、停止するようにメソッドチェーンでオペレーターを追加して変更することもできる。幸い、停止する→停止しないは不可能なのだが、停止しない→停止する という挙動の実装は簡単でパフォーマンスも低下しないのだ。










I consider the automatic unsubscription by OnError to be a bad design for event handling. It's very difficult and risky to resolve it within an operator like Retry, and it also led to poor performance (there are many questions and complex answers about stopping and resubscribing all over the world). Also, converting OnErrorResume to OnError(OnCompleted(Result.Failure)) is easy and does not degrade performance, but the reverse is impossible. Therefore, the design was changed to not stop by default and give users the choice to stop.

Since the original Rx contract was OnError | OnCompleted, it was changed to OnCompleted(Result result) to consolidate into one method. Result is a readonly struct with two states: Failure(Exception) | Success().

The reason for changing to an abstract class instead of an interface is that Rx has implicit complex contracts that interfaces do not guarantee. By making it an abstract class, we fully controlled the behavior of Subscribe, OnNext, and Dispose. This made it possible to manage the list of all subscriptions and prevent subscription leaks.






Stopping the pipeline at OnError is a billion-dollar mistake.




IScheduler is the root of poor performance.
Frame-based operations, a missing feature in Rx, are especially important in game engines.


The Necessity of a subscription list to prevent subscription leaks (similar to a Parallel Debugger)






「全てのObservableは完了する」ということ。そしてR3で最重要視しているのは購読の管理で、徹底的なリーク防止に比重を置いている。分かりやすいのはObservable Trackerによる全ての購読の追跡だが、概念として重要なのは「全て完了する」ようにしたことだ。

Rxにおける購読の管理の基本はIDisposableをDisposeすることだが、購読を解除する方法はそれだけではなく、OnError | OnCompletedが流れることでも解除される。シーケンスの上流と下流、両面からハンドリングすることでリークをより確実に防ぐことができる。対応として過剰だが、購読管理は過剰なぐらいがちょうどいい。そうした思想から、R3では、今までOnCompletedを発行する手段のなかったObservable.FromEventやObservable.Timer、EveryUpdateなども、OnCompletedを発行可能になった。なお、発行方法はCancellationTokenを渡すことで、これもasync/await以降に多用（あるいは濫用）されるようになったCancellationTokenを活用する現代的なAPI設計になる。また、こうした全てのObservableは完了する、という思想があるため、SubjectのDisposeも標準でOnCompletedを発行するように変更した。




ISchedulerを撤廃したことにある。ISchedulerはそもそも性能面では問題の塊のため、今までですら内部的には半分internalなインターフェイスを通して処理するなど回避されてきた代物で、また、ImmediateSchedulerやCurrentSchedulerなど同期的な処理を行うものはあまりにも性能が悪かった。そもそも、非同期な処理を同期的に行えてしまう(例えばDelayにImmediateSchedulerを指定すればThread.Sleepする)ということそのものが悪で忌避されるものである。

そこで .NET 8から導入されたTimeProvider(NuGetから入れることも可能なため非.NET 8でも導入可能)を全面的に採用し、スケジューラーを指定するということは必ず非同期な呼び出しであるということを徹底した。TimeProviderではGetTimestampによる高精度なタイムスタンプ取得と、CreateTimerによるperiodic timerの発火を活用している。また、付随するFakeTimeProviderによってユニットテストが容易になったのも嬉しい。

他のRxでは見かけないがUniRxで絶大な効果を発揮したものとして、フレームベースのオペレーター郡がある。時間とフレームは概念的には似たものであり、ゲームエンジンだけでなくUI処理ではメッセージループやレンダリングループという形で、様々なフレームワークに存在している。そこで、R3では新しくTimerProviderと対になるFrameProviderという形で抽象化した。これによってUnityだけに提供されているフレームベースのオペレーターが、C#が動作するあらゆるフレームワーク(WinForms, WPF, Godot, Avalonia, Stride, etc...)で動作せることができるようになった。もちろん、そうなればUnityにベッタリである必要はないので、コア部分は.NETライブラリとして独立し、UniRxはそのUnity拡張という形で実現されることになった。











async/await Integration
---

Single asynchronous operations should be entirely left to async/await.
Synchronous APIs should not be implemented.





for All Platforms
---





Pull IAsyncEnumerable vs Push Observable
---


NuGetForUnity
---




dotnet/reactive, UniRxからの移行
---






まとめ
---
この再構築ができるのって私しかいないんですよね。とても偉そうですが！最初期からのRxの歴史と実装を知っていて、自分でRxそのものの実装(UniRx)を行い、それが世の中に広く使われることで多くのユースケースや問題点を知り、自分自身もゲームタイトルの実装で大規模に使われるRxのアプリケーション側にも関わり、Rxと対となるasync/awaitの独自ランタイム(UniTask)を実装し、それも世の中に広く使われていることで、この領域に関してのあらゆる知見がある。そして、(Microsoft)公式に立ち向かうだけのやる気と実装力がある。

正直、実装はかなり大変だったんですが、私がやるしかないという使命感駆動開発によりなんとかなりました。なんとかなった！

今回UniRxの実績があったからというのもあり、プレビュー公開時から多くのフィードバックがもらえたことは嬉しかったです(UniTask初公開時は、Unityのコンパイラを実験的コンパイラに差し替える必要があるとかいうエクストリーム仕様だったせいか、しばらくの間は誰も使ってくれなかったというか意義を分かってくれなかったので……）。

。


オリジナル
や現在のRx.NETの維持
リスペクトはある
