# ZLogger v2

C#用の新しい超高速＆低アロケーションの.NET用ロギングライブラリ、ZLogger v2を公開しました。v1からは何もかもを完全に作り替えた、最新のC#に合わせた新設計になっています。対応プラットフォームは.NET 8が最良ですが .NET Standard 2.0 以上、また Unity 2022.2 以上にも対応しています。

* [Cysharp/ZLogger](https://github.com/Cysharp/ZLogger)

新設計のキーポイントはC# 10.0から強化されたString Interpolationの全面採用で、



logger.ZLogInformation($"Hello my name is {name}, {age} years old.");



非常に高速、かつ、以前に紹介したZStringをバックエンドに持つことにより、文字列整形時のアロケーションをなくしています。主に .NET Core 向けに開発したものですが、Unity(IL2CPPやモバイル環境を含む）でも動くように調整してあります




ZLogger – .NET CoreとUnityのためのゼロアロケーション構造化ロガー
https://tech.cygames.co.jp/archives/3401/






Unity
---
UnityはUnity 2023の時点でも正式な対応C#のバージョンは9.0です。ZLoggerはC# 10.0以上のString Interpolationが大前提となっているので、普通は動きません。普通は。ところが、正式にアナウンスはされていないのですが `Unity 2022.2` から同梱されているコンパイラのバージョンが上がっていて、内部的にはC# 10.0でコンパイル可能になっていることを発見しました。

`csc.rsp` ファイルによってコンパイラオプションを渡すことができるので、そこで明示的に言語バージョンを指定してあげると、C# 10.0の全ての文法が利用可能になります。

```csharp
-langVersion:10
```

このままだと出力されるcsprojには依然として`<LangVersion>9.0</LangVersion>`が指定されているため、IDE上ではC# 10.0で書けません。そこで[Cysharp/CsprojModifier](https://github.com/Cysharp/CsprojModifier)を用いて、LangVersionを上書きしてしまいましょう。以下のような`LangVersion.props`というファイルを作成して、CsprojModifierに混ぜてもらえば、IDE上でもC# 10.0として記述できるようになります。

```xml
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <LangVersion>10</LangVersion>
    <Nullable>enable</Nullable>
  </PropertyGroup>
</Project>
```

Unity向けには`AddZLoggerUnityDebug`という拡張を追加してあるので、

```csharp
// こんなグローバルのユーティリティーを用意してあげて
public static class LogManager
{
    static ILoggerFactory loggerFactory;

    public static ILogger<T> CreateLogger<T>() => loggerFactory.CreateLogger<T>();
    public static readonly Microsoft.Extensions.Logging.ILogger Global;

    static LogManager()
    {
        loggerFactory = LoggerFactory.Create(logging =>
        {
            logging.SetMinimumLevel(LogLevel.Trace);
            logging.AddZLoggerUnityDebug(); // log to UnityDebug
        });
        Global = loggerFactory.CreateLogger("Logger");

        Application.exitCancellationToken.Register(() =>
        {
            loggerFactory.Dispose(); // flush when application exit.
        });
    }
}

// 例えばこんな感じに使ってみる
public class NewBehaviourScript : MonoBehaviour
{
    static readonly ILogger<NewBehaviourScript> logger = LogManager.CreateLogger<NewBehaviourScript>();

    void Start()
    {
        var name = "foo";
        var hp = 100;
        logger.ZLogInformation($"{name} HP is {hp}.");
    }
}
```

JSONによる構造化ログや出力のカスタマイズ、ファイルへの出力などにも全て対応しています。

```csharp
var loggerFactory = LoggerFactory.Create(logging =>
{
    logging.AddZLoggerFile("/path/to/logfile", options =>
    {
        options.UseJsonFormatter();
    });
});
```

そしてもう一つボーナスとして、`Unity 2022.3.12f1` 以上だとC#のコンパイラバージョンがもう少し上がっていて、`-langVersion:preview`を指定するとC# 11.0が使えます。また、ZLoggerのSource Generatorが自動で有効になっているので、`[ZLoggerMessage]`を使って生成することができます。

```csharp
public static partial class LogExtensions
{
    [ZLoggerMessage(LogLevel.Debug, "Hello, {name}")]
    public static partial void Hello(this ILogger<NewBehaviourScript> logger, string name);
}
```

Source Generatorの生成するコードがC# 11.0を要求するので(UTF8 String Literalなどを多用しているため)、`[ZLoggerMessage]`が使えるのは`Unity 2022.3.12f1` 以上限定となります。

なお、Unityには同種の標準ロギングライブラリとして[com.unity.logging](https://docs.unity3d.com/Packages/com.unity.logging@1.2/manual/index.html)がリリースされています。同じように構造化ロギングやファイル出力が可能なほか、Source Generatorを使ってクラスそのものを自動生成して、メソッドのオーバーロードを引数に応じて生成することで値のボクシング避けをするといった、面白い設計をしていました。Burst云々という話がよく出てきますが、このSource Generatorの大胆な使い方のほうがパフォーマンスの肝だと思いますねえ。ZLoggerはC# 10.0のString Interpolationを活用しているわけですが、そういうアプローチでの回避策というのはちょっと考えたことがなかったので、かなり目から鱗です。パフォーマンス的にもかなり練られています。

ZLoggerのほうがString Interpolationによる書き味は上、パフォーマンスは、まぁいい勝負するんじゃないかなとは思いたいんですが、どうでしょうね……？

まとめ
---
この記事は[C# Advent Calendar 2023](https://qiita.com/advent-calendar/2023/csharplang)の12月3日分の記事となります。すごい遅刻ですが間に合ったので（？）よし。よくない。

なお、ZLogger v2の作成にあたっては VContainer や VYaml で......

