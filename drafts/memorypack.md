# TODO:Title

MemoryPackという、C#に特化することで従来のシリアライザーとは比較にならないほどのパフォーマンスを発揮する新しいシリアライザーを開発しました。

// TODO:Graph貼る

// TODO:NuGet

高速なバイナリシリアライザーである MessagePack for C# と比較しても、通常のオブジェクトでも数倍、データが最適な場合は100倍ほどのパフォーマンスにもなります。System.Text.Jsonとでは全く比較になりません。当初は .NET 7 限定としてリリースしましたが、現在は .NET Standard 2.1(.NET 5, 6)やUnity、そしてTypeScriptに対応しています。

シリアライザーのパフォーマンスは「データフォーマットの仕様」と「各言語における実装」の両輪で成り立っています。例えば、一般的にはバイナリフォーマットのほうがテキストフォーマット（JSONとか）よりも有利ですが、バイナリシリアライザーより速いJSONシリアライザといったものは有り得ます(Utf8Jsonでそれを実証しました)。では最速のシリアライザーとは何なのか？というと、仕様と実装が最強に極まっていれば、真の最速のシリアライザーが誕生します。それがMemoryPackです。

私は、今もですが、長年[MessagePack for C#](https://github.com/neuecc/MessagePack-CSharp)の開発とメンテナンスをしてきました。MessagePack for C#は .NET の世界で非常に成功したシリアライザーで、4000以上のGitHub Starと、Visual Studio内部や、SignalR, Blazor Serverのバイナリプロトコルなど、Microsoftの標準プロダクトにも採用されています。また、この5年間で1000近くのIssueをさばいてきました。そのため、シリアライザーの実装の詳細からユーザーのリアルなユースケース、要望、問題などを把握しています。Roslynを使用したコードジェネレーターによるAOT対応にも当初から取り組み、特にAOT環境(IL2CPP)であるUnityで実証してきました。更にMessagePack for C#以外にも ZeroFormatter(独自フォーマット)、Utf8Json(JSON) といった、これも多くのGitHub Starを獲得したシリアライザーを作成してきているため、異なるフォーマットの性能特性についても深く理解しています。シリアライザーを活用するシチュエーションにおいても、RPCフレームワーク[MagicOnion](https://github.com/Cysharp/MagicOnion/)の作成、インメモリデータベース[MasterMemory](https://github.com/Cysharp/MasterMemory)、そして複数のゲームタイトルにおけるクライアント(Unity)/サーバーの実装に関わってきました。

ようするところ私は .NET のシリアライザー実装について最も詳しい人間の一人であり、MemoryPackはその知見がフルに詰め込まれた、なおかつ、 .NET 7 / C# 11という最新のランタイム/言語機能を使い倒したライブラリになっています。そりゃ速くて当然で異論はないですよね？というだけではアレなので、じゃあ実際なんで速いのかというのを理屈で説明していきます……！

C#のためのバイナリ仕様
---
キャッチコピーは「Zero encoding」ということで、エンコードしないから速いんだ！という謎理論を打ち出しています。なるほどそりゃヤバいですね実用じゃないですね、みたいに言われることもありますが、例えばRustのメジャーなバイナリシリアライザーである[bincode](https://github.com/bincode-org/bincode)なども似通った仕様を持っています。[FlatBuffers](https://github.com/google/flatbuffers)も、without parsingな実装のために、メモリデータに近い内容を読み書きします。ただしMemoryPackはFlatBuffersと違い、特別な型を必要としない汎用的なシリアライザーであり、POCOに対してのシリアライズ/デシリアライズを行うものです。また、スキーマのメンバー追加へのバージョニング耐性やポリモーフィズムサポート(Union)も持ちます。さすがにメモリダンプしてるだけ、では全く実用にならないわけで、一般的なシリアライザーとして使えるための仕様として整えてあります。

## varint encoding

Int32は4バイトですが、例えばJSONでは数値を文字列として、1バイト~11バイト(例えば `1` であったり `-2147483648` であったり)の可変長なエンコーディングが施されます。バイナリフォーマットでも、サイズの節約のために1~5バイトの可変長にエンコードされる仕様を持つものが多くあります。例えば[Protocol Buffersの数値型](https://developers.google.com/protocol-buffers/docs/encoding#int-types)はZigZagエンコーディングという、値を7ビットに、後続があるかないかのフラグを1ビットに格納する可変長整数エンコーディングになっています。これにより数値が小さければ小さいほど、バイト数が少なくなります。逆にワーストケースでは本来の4バイトより大きい5バイトに膨れることになります。とはいえ現実的には小さい数値のほうが圧倒的に頻出するはずなので、とても理にかなった方式です。[MessagePack](https://github.com/msgpack/msgpack/blob/master/spec.md)や[CBOR](https://cbor.io/)も同じように、小さい数値では最小で1バイト、大きい場合は最大5バイトになる可変長エンコーディングで処理されます。

さて、つまり、固定長の場合よりも余計な処理が走ることになります。具体的なコードで比較してみましょう。

```csharp
fixed integer


var int
```

固定長は、つまりC#のメモリをそのまま書き出している(Zero encoding)わけで、さすがにどう見ても固定長のほうが速いでしょう。

このことは配列に適用した場合、より顕著になります。

int[]


C#のstructの配列は、データが直列に並びます。この時、[structが参照型を持っていない場合(unamanged type)](https://learn.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/unmanaged-types)は、データが完全にメモリ上に並んでいることになります。MessagePackとMemoryPackでコードでシリアライズ処理を比較してみましょう。

// TODO: code





Vector3[]


float(4バイト)はMessagePackにおいて、固定長で5バイトです。追加の1バイトは、その値が何の型(IntなのかFloatなのかStringなのか...)を示す識別子が先頭に入ります。具体的には[0xca, x, x, x, x]といったように。いわばタグ付与エンコーディングを行っているわけです。MemoryPackでは4バイトをそのまま書き込みます。



C#の配列は、これは複数のプリミティブを持ったstructでも同様の話で、例えば(float x, float y, float z)を持つVector3の配列の場合は、以下のようなメモリレイアウトになります。

// TODO: image

これをMessagePackでシリアライズすると以下のようになります。

// TODO: msgpack serialized

しかしMemoryPackでシリアライズすると、ただのメモリコピーで済みます。


Vector[10000]であったら、MessagePackだと30000回のメソッド呼び出しが必要なところが(そしてそのメソッド内では、書き込みメモリが足りているかのチェックと、書き終わった後のオフセットの追加が(愚直に処理する場合)都度必要になる)、一回のメモリコピーだけになります。さすがにこれは処理時間が文字通り桁違いに変わってきて、冒頭のグラフの50倍~100倍の高速化の理由はここにあります。

もちろん、デシリアライズ処理もコピー一発になります。

// code




// サイズについて

columnar compression, LZ4




string


UTF8/UTF16


// encode

// decode


現在のC#では `ReadOnlySpan<byte>` がUTF8の

memberにならない

Utf8Stringが欲しい。


ハイパフォーマンスシリアライザーのための実装
---











まとめ
---
なんで開発しようかと思ったかというと、まぁMessagePack for C#に不満がでてきたから、です。残念ながら .NET「最速」とはいえないような状況があり、その理由としてバイナリ仕様が足を引っ張っているため、改善するのにも限界があることには随分前から気づいていました。また、実装面でもIL生成とRoslynを使った外部ツールとしてのコードジェネレーター(mpc)の、二種のメンテナンスがかなり厳しくなってきているということもありました。また、外部ツールとしてのコードジェネレーターはトラブルの種で、何かと環境によって動かないということが多発していて、Source Generatorにフル対応できるのなら、もはや廃止したいぐらいに思ってもいました。

そこに .NET 7/C# 11 の ref fieldやstatic abstract methodを見た時、これをシリアライザー開発に応用したらパフォーマンスの底上げが可能になる、ついでにSource Generator化すれば、いっそIL生成も廃止してSource Generatorに一本化できるのではないか？それならもう、それをMessagPack for C#に適用する前に、パフォーマンス向上に問題のあるバイナリ仕様の限界も無視した、C#のためだけに究極の性能を実現するシリアライザーを作って、本当の最速を実証してしまえばいいのでは？という欲求が頭に浮かび……。

とはいえ改めてベンチマークを色々取ってみると、 MessagePack for C# は非常に高速で、安定していて、他言語との相互運用性もあり、バージョニングにもフル対応できるので、全く悪くないというかとても良い選択です。今後もメンテナンスにも関わります。ただし、MemoryPackのほうが速い。速さは麻薬なので、比較してしまうと、どうしてもなんとなく選びたくないような雰囲気にはなります。

// TODO:もう少しなにか書く