# ZLogger v2(TODO:title)

C#用の新しい超高速＆低アロケーションの.NET用ロギングライブラリ、ZLogger v2を公開しました。v1からは何もかもを完全に作り替えた、最新のC#に合わせた新設計になっています。対応プラットフォームは.NET 8が最良ですが .NET Standard 2.0 以上、また Unity 2022.2 以上にも対応しています。.NET / Unityどちらもテキストメッセージと構造化ログの両方に対応しています。

* [Cysharp/ZLogger](https://github.com/Cysharp/ZLogger)

新設計のキーポイントはString Interpolationの全面採用によるクリーンなシンタックスとパフォーマンスの両立です。

```csharp
logger.ZLogInformation($"Hello my name is {name}, {age} years old.");
```

といったように書いたコードは

```csharp
if (logger.IsEnabled(LogLvel.Information))
{
    var handler = new ZLoggerInformationInterpolatedStringHandler(30, 2, logger);
    handler.AppendLiteral("Hello my name is ");
    handler.AppendFormatted<string>(name, 0, null, "name");
    handler.AppendLiteral(", ");
    handler.AppendFormatted<int>(age, 0, null, "age");
    handler.AppendLiteral(" years old.");
}
```

のようにコンパイル時に分解されます。フォーマット文字列を実行時ではなくコンパイル時に展開すること、パラメーターは`AppendFormatted<T>`の形でジェネリクスで受け取ることによりボクシングが発生しないなど、コードからも明らかに効率的なことが見てとれます。ちなみにコンストラクターの30は文字列の長さ、2はパラメーターの数を指していて、ここから必要な初期バッファ数を算出していることも効率化の一つに繋がっています。

String Interpolation自体はC# 6.0から搭載されている機能ですが、文法上同じながら[C# 10.0から強化されたString Interpolation](https://devblogs.microsoft.com/dotnet/string-interpolation-in-c-10-and-net-6/)が搭載されていて、カスタムのString Interpolationを提供することも可能になりました。

こうして得られた文字列断片とパラメーターは、最終的には[Cysharp/Utf8StringInterpolation](https://github.com/Cysharp/Utf8StringInterpolation)を通して文字列化せずに、直接UTF8としてStreamに書き込むことによって、高速化と低アロケーションを実現しています。

また、Structured Loggingにおいても、System.Text.JsonのUtf8JsonWriterとタイトに結びつくことにより

```csharp
// 例えば {"name":"foo",age:33} のようにUtf8JsonWriterに書き込む

// Source Generator版、実際どうなってるかのイメージがとても分かりやすい。
public void WriteJsonParameterKeyValues(Utf8JsonWriter writer, JsonSerializerOptions jsonSerializerOptions)
{
    writer.WriteString(_jsonParameter_name, this.name);
    writer.WriteNumber(_jsonParameter_age, this.age);
}

// StringInterpolation版、ちょっと遠回りな感じですがやってることは一緒。
public void WriteJsonParameterKeyValues(Utf8JsonWriter writer, JsonSerializerOptions jsonSerializerOptions)
{
    for (var i = 0; i < ParameterCount; i++)
    {
        ref var p = ref parameters[i];
        writer.WritePropertyName(p.Name.AsSpan());
        // MagicalBoxの説明は後述
        if (!magicalBox.TryReadTo(p.Type, p.BoxOffset, jsonWriter, jsonSerializerOptions))
        {
            // ....
        }
    }
}
```

やはり直接UTF8として書き込みます。Structured Loggingは最近のトレンドなので、色々な言語のロガーに実装されていますが、パフォーマンスを両立しつつ、ここまでクリーンなシンタックスで実現できているものは他にない！という感じなのでかなり良いのではないでしょうか。

では実際ベンチマーク結果でどれぐらい？というと、アロケーションは少なくとも圧倒的です。

![image](https://github.com/Cysharp/ZLogger/assets/46207/ab9c1f8b-a3b4-44fc-86aa-ba8dd6bdbe40)

アロケーションは、という歯切れの悪い言い方をしているのは、念入りに高速になるよう設定したNLogが思ったよりも速かったせいですね、ぐぬぬ……。

さて、ZLoggerの特徴のもう一つは、[Microsoft.Extensions.Logging](https://learn.microsoft.com/ja-jp/dotnet/core/extensions/logging)の上に直接構築していることです。通常のロガーは独自のシステムを持っていて、Microsoft.Extensions.Loggingと繋げる場合はブリッジを通します。現実的なアプリケーションでは ASP .NETを使う場合などMicrosoft.Extensions.Loggingを避けることはほぼ不可能です。.NET 8からはOpenTelemetry対応の強化や[Aspire](https://learn.microsoft.com/en-us/dotnet/aspire/get-started/aspire-overview)など、ますますMicrosoft.Extensions.Loggingの重要性は増しています。ZLogger v1と異なり、v2ではScopeなど、Microsoft.Extensions.Loggingの全機能に対応しています。

そして例えばSerilogのブリッジライブラリの品質は（ソースコードも確認しましたが）かなり低く、実際のパフォーマンスの数字にも現れています。ZLoggerはそうしたオーバーヘッドが一切かかりません。

また、デフォルトの設定も非常に重要です。ほとんどのロガーの標準設定は、例えばファイルストリームに書く場合は都度Flushするなど、かなり遅い設定が標準になっています。それを高速化するにはasync, bufferedを適切に調整する必要があり、かつ、取りこぼさないように終了時に確実にFlushさせる必要があるのですが、かなり難しいので、ほとんど標準設定のままの人も多いのではないでしょうか？ZLoggerではデフォルトで最高速になるように調整してあり、かつ、Microsoft.ExtensionsのDIのライフサイクルで最後のFlushも自動でかかるようになっているので、ApplicationBuilderなどでアプリケーションを構築した場合は何も意識しなくても取りこぼしは発生しません。

なお、都度Flushのパフォーマンスはストレージの書き込み性能に強く依存するため、例えば最近のマシンのM.2 SSDは非常に高速なため、ローカルでベンチマークすると意外と遅くない、といったことを確認できるかもしれません。ただし、実際にアプリケーションを配置する、例えばクラウドサーバーのストレージ性能がそこまで高いことはないので、ローカルでの結果を過信しないほうがいいでしょう。

MagicalBox
---
ここからは、パフォーマンスを実現した幾つかのトリックを紹介します。v1から引き継いでいるのは[System.Threading.Channels](https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/)を活用したasyncな非同期書き込みプロセスの作成と、[`IBufferWriter<byte>`](https://learn.microsoft.com/ja-jp/dotnet/api/system.buffers.ibufferwriter-1)による効率的なbufferedの利用による、Streamへの書き込み最適化ですが、説明は割愛します。

JSON化のために、パラメーターはInterpolatedStringHandlerで、一時的に値として保持します。その場合に、`<T>`の値をどのように保持するか、という問題がでてきます。普通に考えると、`List<object>`といったようなobject型で保持することになります。

```csharp
[InterpolatedStringHandler]
public ref struct ZLoggerInterpolatedStringHandler
{
    // あらゆる<T>の型を格納するためにobjectを使う、ボクシングが発生するので良くはない。
    List<object> parameters = new ();

    public void AppendFormatted<T>(T value, int alignment = 0, string? format = null, [CallerArgumentExpression("value")] string? argumentName = null)
    {
        parameters.Add((object)value);
    }
}
```

それを避けるために、ZLoggerではMagicalBoxという仕組みを用意しました。

```csharp
[InterpolatedStringHandler]
public ref struct ZLoggerInterpolatedStringHandler
{
    // 魔法の箱に無限に詰め込む
    MagicalBox magicalBox;
    List<int> boxOffsets = new (); // 実際はこの辺は入念にキャッシュされています

    public void AppendFormatted<T>(T value, int alignment = 0, string? format = null, [CallerArgumentExpression("value")] string? argumentName = null)
    {
        if(magicalBox.TryWrite(value, out var offset)) // boxingが発生しない！
        {
            boxOffsets.Add(offset);
        }
    }
}
```

MagicalBoxはどんな型(unmanaged型に限る)でも、ボクシングなしに書き込むことができる。というコンセプトで、その実態は`byte[]`にUnsafe.Write、offsetを元にUnsafe.Readするというだけの代物です。

```csharp
internal unsafe partial struct MagicalBox
{
    byte[] storage;
    int written;

    public MagicalBox(byte[] storage)
    {
        this.storage = storage;
    }

    public bool TryWrite<T>(T value, out int offset)
    {
        if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            offset = 0;
            return false;
        }

        Unsafe.WriteUnaligned(ref storage[written], value);
        offset = written;
        written += Unsafe.SizeOf<T>();
        return true;
    }

    public bool TryRead<T>(int offset, out T value)
    {
        if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
        {
            value = default!;
            return false;
        }

        value = Unsafe.ReadUnaligned<T>(ref storage[offset]);
        return true;
    }
}
```

この辺は[MemoryPack](https://github.com/Cysharp/MemoryPack)での実装経験が元になっていて、うまく機能しています。

なお、実際のコードでは`byte[] storage`の効率的な再利用や非ジェネリクスなRead対応、Enumへの特別対応が入ったりなど、もう少し[複雑なコード](https://github.com/Cysharp/ZLogger/blob/ccc3b0e6/src/ZLogger/Internal/MagicalBox.cs)になってはいます。さすがに。

カスタムフォーマット文字列
---
ZLoggerのString Interpolationのいいところは、パラメーター値にメソッド呼び出しを含めると、LogLevelのチェックが入った後に呼び出されるので無駄な実行を防げるところです。

```csharp
// これは
logger.ZLogDebug($"Id {obj.GetId()}: Data: {obj.GetData()}.");

// このようにLogLevelが有効かどうかチェックした後にメソッドが呼ばれる
if (logger.IsEnabled(LogLvel.Debug))
{
    // snip...
    writer.AppendFormatterd(obj.GetId());
    writer.AppendFormatterd(obj.GetData());
}
```

しかし、メソッド呼び出しをStructured Loggingに出力した場合、ZLoggerはC# 10.0以降から追加された[CallerArgumentExpression](https://learn.microsoft.com/ja-jp/dotnet/api/system.runtime.compilerservices.callerargumentexpressionattribute?view=net-8.0)でパラメーター名を取得しているため、メソッド呼び出しの場合は "obj.GetId()" という






.NET 8 IUtf8SpanFormattable / TimeProvider
---

```csharp

static readonly ConcurrentDictionary<LiteralList, MessageSequence> cache = new();

        readonly struct LiteralList : IEquatable<LiteralList>
        {
            readonly List<string?> literals;

            public LiteralList(List<string?> literals)
            {
                this.literals = literals;
            }

#if NET8_0_OR_GREATER

            // literals are all const string, in .NET 8 it is allocated in Non-GC Heap so can compare by address.
            // https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#non-gc-heap
            static ReadOnlySpan<byte> AsBytes(ReadOnlySpan<string?> literals)
            {
                return MemoryMarshal.CreateSpan(
                    ref Unsafe.As<string?, byte>(ref MemoryMarshal.GetReference(literals)),
                    literals.Length * Unsafe.SizeOf<string>());
            }

            public override int GetHashCode()
            {
                return unchecked((int)XxHash3.HashToUInt64(AsBytes(CollectionsMarshal.AsSpan(literals))));
            }

            public bool Equals(LiteralList other)
            {
                var xs = CollectionsMarshal.AsSpan(literals);
                var ys = CollectionsMarshal.AsSpan(other.literals);

                return AsBytes(xs).SequenceEqual(AsBytes(ys));
            }

#else

            [ThreadStatic]
            static XxHash3? xxhash;

            public override int GetHashCode()
            {
                var h = xxhash;
                if (h == null)
                {
                    h = xxhash = new XxHash3();
                }
                else
                {
                    h.Reset();
                }

                var span = CollectionsMarshal.AsSpan(literals);
                foreach (var item in span)
                {
                    h.Append(MemoryMarshal.AsBytes(item.AsSpan()));
                }

                // https://github.com/Cyan4973/xxHash/issues/453
                // XXH3 64bit -> 32bit, okay to simple cast answered by XXH3 author.
                return unchecked((int)h.GetCurrentHashAsUInt64());
            }

            public bool Equals(LiteralList other)
            {
                var xs = CollectionsMarshal.AsSpan(literals);
                var ys = CollectionsMarshal.AsSpan(other.literals);

                if (xs.Length == ys.Length)
                {
                    for (int i = 0; i < xs.Length; i++)
                    {
                        if (xs[i] != ys[i]) return false;
                    }
                    return true;
                }

                return false;
            }

#endif
        }
```






.NET 8 IUtf8SpanFormattable / TimeProvider
---


```csharp
public class TimestampTest
{
    class FakeTime : TimeProvider
    {
        public override DateTimeOffset GetUtcNow()
        {
            return new DateTimeOffset(1999, 12, 30, 11, 12, 33, TimeSpan.Zero);
        }

        public override TimeZoneInfo LocalTimeZone => TimeZoneInfo.Utc;
    }

    string GetLogString(MessageTemplateHandler prefixTemplate)
    {
        LogProcessor processor = new();
        var factory = LoggerFactory.Create(builder =>
        {
            builder.AddZLoggerLogProcessor(options =>
            {
                options.TimeProvider = new FakeTime();
                options.UsePlainTextFormatter(formatter =>
                {
                    formatter.SetPrefixFormatter(prefixTemplate, (template, info) => template.Format(info.Timestamp));
                });
                processor.SetOptions(options);

                return processor;
            });
        });

        var logger = factory.CreateLogger("foo");
        logger.ZLogInformation($"");

        factory.Dispose();
        return processor.WrittenData;
    }

    [Fact]
    public void TimestampFormatTest()
    {
        GetLogString($"{0}").Should().Be("1999-12-30 11:12:33.000");
        GetLogString($"{0:datetime}").Should().Be("1999-12-30 11:12:33");
        GetLogString($"{0:dateonly}").Should().Be("1999-12-30");
        GetLogString($"{0:timeonly}").Should().Be("11:12:33");
    }
}

```

Source Generator
---



Unity
---
UnityはUnity 2023の時点でも正式な対応C#のバージョンは9.0です。ZLoggerはC# 10.0以上のString Interpolationが大前提となっているので、普通は動きません。普通は。ところが、正式にアナウンスはされていないのですが `Unity 2022.2` から同梱されているコンパイラのバージョンが上がっていて、内部的にはC# 10.0でコンパイル可能になっていることを発見しました。

`csc.rsp` ファイルによってコンパイラオプションを渡すことができるので、そこで明示的に言語バージョンを指定してあげると、C# 10.0の全ての文法が利用可能になります。

```csharp
-langVersion:10
```

このままだと出力されるcsprojには依然として`<LangVersion>9.0</LangVersion>`が指定されているため、IDE上ではC# 10.0で書けません。そこで[Cysharp/CsprojModifier](https://github.com/Cysharp/CsprojModifier)を用いて、LangVersionを上書きしてしまいましょう。以下のような`LangVersion.props`というファイルを作成して、CsprojModifierに混ぜてもらえば、IDE上でもC# 10.0として記述できるようになります。

```xml
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <LangVersion>10</LangVersion>
    <Nullable>enable</Nullable>
  </PropertyGroup>
</Project>
```

Unity向けには`AddZLoggerUnityDebug`という拡張を追加してあるので、

```csharp
// こんなグローバルのユーティリティーを用意してあげて
public static class LogManager
{
    static ILoggerFactory loggerFactory;

    public static ILogger<T> CreateLogger<T>() => loggerFactory.CreateLogger<T>();
    public static readonly Microsoft.Extensions.Logging.ILogger Global;

    static LogManager()
    {
        loggerFactory = LoggerFactory.Create(logging =>
        {
            logging.SetMinimumLevel(LogLevel.Trace);
            logging.AddZLoggerUnityDebug(); // log to UnityDebug
        });
        Global = loggerFactory.CreateLogger("Logger");

        Application.exitCancellationToken.Register(() =>
        {
            loggerFactory.Dispose(); // flush when application exit.
        });
    }
}

// 例えばこんな感じに使ってみる
public class NewBehaviourScript : MonoBehaviour
{
    static readonly ILogger<NewBehaviourScript> logger = LogManager.CreateLogger<NewBehaviourScript>();

    void Start()
    {
        var name = "foo";
        var hp = 100;
        logger.ZLogInformation($"{name} HP is {hp}.");
    }
}
```

> なお、C# 10.0のString Interpolation性能向上の恩恵を受けれるのはZLogを使った場合のみの話で、通常のString生成にString Interpolationを使っても性能向上はしません。string生成の性能向上にはランタイムにDefaultInterpolatedStringHandlerが必要で、これは .NET 6 以上にのみ同梱されているからです。DefaultInterpolatedStringHandlerが存在しない場合は今まで通りのstring.Formatにフォールバックされるため、普通にボクシングされます。

JSONによる構造化ログや出力のカスタマイズ、ファイルへの出力などにも全て対応しています。

```csharp
var loggerFactory = LoggerFactory.Create(logging =>
{
    logging.AddZLoggerFile("/path/to/logfile", options =>
    {
        options.UseJsonFormatter();
    });
});
```

そしてもう一つボーナスとして、`Unity 2022.3.12f1` 以上だとC#のコンパイラバージョンがもう少し上がっていて、`-langVersion:preview`を指定するとC# 11.0が使えます。また、ZLoggerのSource Generatorが自動で有効になっているので、`[ZLoggerMessage]`を使って生成することができます。

```csharp
public static partial class LogExtensions
{
    [ZLoggerMessage(LogLevel.Debug, "Hello, {name}")]
    public static partial void Hello(this ILogger<NewBehaviourScript> logger, string name);
}
```

Source Generatorの生成するコードがC# 11.0を要求するので(UTF8 String Literalなどを多用しているため)、`[ZLoggerMessage]`が使えるのは`Unity 2022.3.12f1` 以上限定となります。

なお、Unityには同種の標準ロギングライブラリとして[com.unity.logging](https://docs.unity3d.com/Packages/com.unity.logging@1.2/manual/index.html)がリリースされています。同じように構造化ロギングやファイル出力が可能なほか、Source Generatorを使ってクラスそのものを自動生成して、メソッドのオーバーロードを引数に応じて生成することで値のボクシング避けをするといった、面白い設計をしていました。Burst云々という話がよく出てきますが、このSource Generatorの大胆な使い方のほうがパフォーマンスの肝だと思います。ZLoggerはC# 10.0のString Interpolationを活用しているわけですが、そういうアプローチでの回避策というのはちょっと考えたことがなかったので、かなり目から鱗です。パフォーマンス的にもかなり練られています。

ZLoggerのほうがString Interpolationによる書き味は上、パフォーマンスは、まぁいい勝負するんじゃないかなとは思いたいんですが、どうでしょうね……？

NuGetForUnity
---
TODO:


まとめ
---
この記事は[C# Advent Calendar 2023](https://qiita.com/advent-calendar/2023/csharplang)の12月3日分の記事となります。すごい遅刻ですが間に合ったので（？）よし。よくない。

なお、ZLogger v2の作成にあたっては [VContainer](https://github.com/hadashiA/VContainer) や [VYaml](https://github.com/hadashiA/VYaml) で有名な [@hadashiA](https://twitter.com/hadashiA) さんに、アイディア出しから細かい実装、度重なる仕様のちゃぶ台返しに付き合ってもらいました。今回のv2は非常に完成度高くなったと思うのですが、自分一人ではここまで達しなかったので大変感謝です。
